---
title: "힙 정렬(heap sort)에 대해 알아보자"
date: "2019-10-29T13:49:14.169Z"
template: "post"
draft: false
slug: "/algorithm/heap_sort/"
category: "algorithm"
tags:

- "algorithm"
- "heap sort"
- "sort"
description: "힙 정렬에 대해 알아보자"


---



> 트리를 구성해 정렬을 하는 **힙 정렬**에 대해 알아보자



1. [힙(heap)](#힙(heap))
2. [힙 정렬 과정](#힙-정렬-과정)
3. [힙 정렬 구현](#힙-정렬-구현-(python))
4. [힙 정렬 특징](#힙-정렬의-특징)
5. [힙 정렬 시간복잡도](#힙-정렬의-시간복잡도)





## 힙 정렬(heap sort) 알고리즘

- 최대 힙 트리나 최소 힙 트리를 구성해 정렬을 하는 방법
- 내림차순 정렬 : 최대 힙, 오름차순 정렬 : 최소 힙 구성



### 힙(heap)

+ 최댓값 및 최솟값을 찾아내는 연산을 빠르게 하기 위해 고안된 자료구조.

+ ![img](img/220px-Max-Heap.svg.png)

  위 그림은 최대 힙으로 모든 부모 노드가 자식 노드보다 큰 값을 갖는다.

자료구조 '힙(heap)'에 대해서는 이후 새로운 글에서 자세히 다루겠다.



### 힙 정렬 과정

1. 주어진 원소들로 최대 힙을 구성
2. 최대 힙의 루트 노드(==현재 배열의 첫 번째 요소 == 최댓값)와 말단 노드(==현재 배열의 마지막 요소)를 교환
3. 새 루트 노드에 대해 최대 힙을 구성
4. 원소의 개수 만큼 2와 3을 반복

이 때, 주어진 자료 구조에서 힙 성질을 만족하도록 하는 연산을 **heapify**라고 한다.(3번 과정)

![Sorting heapsort anim.gif](img/220px-Sorting_heapsort_anim.gif)

<br>

<br>

### 힙 정렬 구현 (python)

```python
def heapify(arr, index, heap_size):
    # 완전이진트리는 배열 하나로 트리 구현가능
    largest = index
    left = index * 2 + 1    # 왼쪽 자식
    right = index * 2 + 2   # 오른쪽 자식
    # 왼쪽 자식이 현재 요소보다 크면 인덱스 교체
    if left < heap_size and arr[left] > arr[largest]:
        largest = left
    # 오른쪽 자식이 현재 요소보다 크면 인덱스 교체
    if right < heap_size and arr[right] > arr[largest]:
        largest = right
    # 교체된적이 있다면 교체된 index와 largest 요소값 교체
    if largest != index:
        arr[largest], arr[index] = arr[index], arr[largest]
        # 변경되었으면 변경된 부분을 중심으로 다시 한번 heapify
        heapify(arr, largest, heap_size)


def heap_sort(arr):
    n = len(arr)

    # 최초 힙
    # 트리의 절반부터 거꾸로 올라가며 heapify를 하는것이 효율적
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, i, n)

    # 한번 구성된 힙을 정렬.
    # 가장 큰 값(루트) 를 가장 끝 값으로 이동한 후 힙 생성.
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify(arr, 0, i)
    return arr


data = [61, 324, 21, 56, 243, 6, 1, 634, 43, 3, 52]
print(heap_sort(data))
```





### 합병 정렬 구현 (C)

```c
#include <stdio.h>

void merge(int *arr, int left, int mid, int right) {
	int temp[20];
	int i = left, j = mid + 1, k = left;
	
	// left의 시작인 i가 mid보다 작거나 같고,
	// mid의 시작인 j가 right보다 작거나 같을때까지
	while (i <= mid && j <= right) {
		// 왼쪽 값이 오른쪽 값보다 작거나 같은 경우 temp 배열에 복사
		if (arr[i] <= arr[j]) temp[k++] = arr[i++];
		// 반대의 경우에 temp에 복사
		else if (arr[i] > arr[j]) temp[k++] = arr[j++];
	}
	// i가 mid보다 커질 경우(왼쪽 값 모두 복사)
	if (i > mid) {
		// 오른쪽 값 모두 복사
		while (j <= right) temp[k++] = arr[j++];
	}
	else {
		// 반대의 경우 왼쪽 값 모두 복사
		while (i <= mid) temp[k++] = arr[i++];
	}
	// 임시 배열의 값을 원래 배열에 복사
	for (int m = left; m <= right; m++) arr[m] = temp[m];
}
void merge_sort(int *arr, int left, int right) {
	if (left < right) {
		int mid = (left + right) / 2;
		// left가 right보다 크거나 같아질 때 까지 반복
		merge_sort(arr, left, mid);
		merge_sort(arr, mid + 1, right);
		// 길이가 비슷해지면 merge
		merge(arr, left, mid, right);
	}
}


int main(void) {
	int data[20] = { 61, 324, 21, 56, 243, 6, 1, 634, 43, 3, 52 };
	int n = 11;
	merge_sort(data, 0, n-1);
	for (int i = 0; i < n; i++) printf("%d ", data[i]);
	return 0;
}
```

<br>

<br>

### 합병 정렬의 특징

- 장점
  - 안정적인 정렬.
  - 데이터 분포에 따른 시간 영향을 덜받는다. 똑같은 크기로 나누어 정렬되기 때문에 시간은 동일하다.
  - 만약 배열을 **linked list(연결 리스트)**로 구현하면 인덱스만 변경되므로 데이터의 이동 및 복사를 하지 않아도 된다.
  - 크기가 큰 배열을 정렬할 경우 연결리스트를 사용한다면, 합병정렬은 어떤 정렬보다도 효율적이다.
- 단점
  - 배열로 구성되어 있을 때, 임시 배열이 필요하다.
  - 크기가 큰 경우 많은 이동횟수가 필요하기 때문에 시간 낭비가 될 수 있다.

<br>

<br>

### 합병 정렬의 시간복잡도

- 분할
  - 단순 분할만 한다. 비교, 이동이 수행되지 않는다.
- 합병
  - 비교 : 각 층마다 n번씩 비교
  - 순환 호출 : 절반씩 나누어 호출되기 때문에 log n
  - 이동 : 임시 배열에 복사했다가 다시 원 배열에 가져와야 하기 때문에 배열의 요소가 n개일 경우, 이동은 2n번 발생.

- T(n) = **O(n log n)**









### Ref.

[위키백과 - 힙 (자료구조)](https://ko.wikipedia.org/wiki/힙_(자료_구조))

[위키백과 - 힙 정렬](https://ko.wikipedia.org/wiki/힙_정렬)

[Heee's Development Blog](<https://gmlwjd9405.github.io/2018/05/10/algorithm-heap-sort.html>)

[ratsgo's blog](https://ratsgo.github.io/data structure&algorithm/2017/09/27/heapsort/)